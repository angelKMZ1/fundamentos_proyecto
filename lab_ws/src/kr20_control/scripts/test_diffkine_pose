#!/usr/bin/env python3

import rospy
from sensor_msgs.msg import JointState
from markers import *
from lab5functions import *

if __name__ == '__main__':
    
    # Initialize the node
    rospy.init_node("testKineControlPose")
    print('starting motion ... ')
    # Publisher: publish to the joint_states topic
    pub = rospy.Publisher('joint_states', JointState, queue_size=1000)
    
    # Markers for the current and desired positions
    bmarker_current = BallMarker(color['RED'])
    bmarker_desired = BallMarker(color['GREEN'])
    
    # Joint names
    jnames = ['base__link01',
              'link12__link01',
              'link01__link02', 
              'link02__link03', 
              'link03__link04', 
              'link04__link05', 
              'link05__gripper',
              'gripper__gripper_left',
              'gripper__gripper_right']
    
    # Desired pose
    ang = pi/3
    Rd = np.array([[0,1,0], [1,0,0], [0,0,-1]])
    qd = rot2quat(Rd)
    
    # Find an xd that the robot can reach (position part only)
    xd = np.array([0.8, 0.0, 0.9])
    
    # Initial configuration
    q0 = np.array([0.0, 0.0, -0.42, -0.32, 0.0, -1.65, 0.0, 0.0, 0.0])
    
    # Resulting initial pose
    T = fkine_kr20(q0)
    x0 = T[0:3,3]
    
    # Markers for the current and desired positions
    bmarker_current.xyz(x0)
    bmarker_desired.xyz(xd)
    
    # Instance of the JointState message
    jstate = JointState()
    # Values of the message
    jstate.header.stamp = rospy.Time.now()
    jstate.name = jnames
    
    # Initial joint configuration
    q = copy(q0)
    x = copy(x0)
    
    # Frequency (in Hz) and control period 
    freq = 200
    dt = 1.0/freq
    rate = rospy.Rate(freq)
    
    # Initialize error
    e = np.zeros(3)
    
    # Ganancia
    k = 0.3
    
    # Main loop
    while not rospy.is_shutdown():
        # Current time (needed for ROS)
        jstate.header.stamp = rospy.Time.now()
        
        # Forward kinematics
        T = fkine_kr20(q)
        x = T[0:3,3]
        
        # Error
        e = xd - x
        
        # If error is small enough, do nothing
        if np.linalg.norm(e) < 0.001:
            print("Goal reached!")
            break
            
        # Get the Jacobian for current position
        J = jacobian_position(q, delta=dt)
        
        # Control law
        dq = k * np.linalg.pinv(J) @ e
        
        # Update joint positions
        q = q + dt * dq
        
        # Publish the message
        jstate.position = q
        pub.publish(jstate)
        
        # Update markers
        bmarker_desired.xyz(xd)
        bmarker_current.xyz(x)
        bmarker_current.publish()
        bmarker_desired.publish()
        
        # Print information
        print("Error actual:", np.linalg.norm(e))
        print("ConfiguraciÃ³n articular:", q)
        
        # Wait for the next iteration
        rate.sleep()
    
    print('ending motion ...')
